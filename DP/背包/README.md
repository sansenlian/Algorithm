# 前言

* 01背包: 每个物品数量只有一个
* 多重背包: 每个物品数量都不同
* 完全背包: 每个物品数量不限制

其实背包问题就是围绕一个公式来解决的
$$
f[i][v]=max({f[i-1][v],f[i-1][v-k*c[i]]+k*w[i]})
$$
其中k就看问题是01还是多重还是完全了

---
01背包经典解法的核心代码
```JavaScript
for(var i = 0 ; i < n ; i++){ 
   for(var j=0; j<=W; j++){ 
       f[i][j] = Math.max(f[i-1][j], f[i-1][j-weights[i]]+values[i]))
      }
   }
}
```
现在多了一个k，就意味着多了一重循环
```JavaScript
for(var i = 0 ; i < n ; i++){ 
   for(var j=0; j<=W; j++){ 
       for(var k = 0; k < j / weights[i]; k++){
          f[i][j] = Math.max(f[i-1][j], f[i-1][j-k*weights[i]]+k*values[i]))
        }
      }
   }
}
```
但时候可以发现, 因为物品i可以无限使用, 所以它的状态就是它自己"i"，而不是上一个"i-1"
![](https://raw.githubusercontent.com/sansenlian/PicPlace/master/img/20190810015352.png)
对于多重背包的优化就很有意思
n(i)为每种背包的数量限制, 如果这样会超时，我们就得考虑更优的拆分方法，由于拆成1太多了，我们考虑拆成二进制数，对于13的数量，我们拆成1，2，4，6（有个6是为了凑数）。 19 我们拆成1，2，4，8，4 （最后的4也是为了凑和为19）。经过这个样的拆分我们可以组合出任意的小于等于n(i)的数目
# 01背包问题

题目: 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

---

> 什么叫01背包问题, 就是一件东西就两种方案, 放或者不放

状态转移方程便是：
$$
f[i][v]=max({f[i-1][v],f[i-1][v-c[i]]+w[i]})
$$

$$
f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值
c[i]表示当前物品的价值
$$

以上方法的时间和空间复杂度均为O(N*V)，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V)。

## 优化方案

每一次 $$dp[i][j] $$的改变只与 $$dp[i-1][x] { x : 1...j } $$有关，$$dp[i-1][x] $$是上一次循环保存下来的值；

因此，可以将 dp 缩成一维数组，从而达到优化空间的目的, 状态转移方程为:
$$
dp[j] = max(dp[j], dp[j-c[i]] + w[i])
$$

# 完全背包问题

### 问题描述

题目: 有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

> 相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。

$$
f[i][v]=max({f[i-1][v],f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<= v})
$$

k代表选取多少件该物品

## 示例

有 N 种物品和一个容量是 C 的背包，每种物品都有无限件可用。第 i 种物品的重量是 wi，价值是 vi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

##### 输入格式：

第一行两个整数，N，C，用空格隔开，分别表示物品种数和背包容积。
 接下来有 N 行，每行两个整数 wi, vi，用空格隔开，分别表示第 i 种物品的重量和价值。

##### 输出格式：

输出一个整数，表示最大价值。

**数据范围：**

- 0 < N, C ≤ 1000
- 0 < wi, vi ≤ 1000

##### 输入样例：

```
4 5
1 2
2 4
3 4
4 5
```

##### 输出样例：

```
10
```

### 多重背包

多重背包问题要求很简单，就是每件物品给出确定的件数，求可得到的最大价值  

也可以转化为01问题
$$
f[i][v]=max({f[i-1][v],f[i-1][v-k*c[i]]+ k*w[i]|0<=k<=n[i]})
$$
k表示从n[i]中去的数量
# Algorithm
 如果要应对面试可以看下这篇文章:

https://www.zhihu.com/question/24964987/answer/586425979

需要掌握的算法有:

其中算法，主要是以下几种：

- 基础技巧：分治、二分、贪心
- 排序算法：快速排序、归并排序、计数排序
- 搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等
- 图论：最短路径、最小生成树、网络流建模
- 动态规划：背包问题、最长子序列

数据结构，主要有如下几种：

- 数组与链表：单 / 双向链表
- 栈与队列
- 哈希表
- 堆：最大堆 ／ 最小堆
- 树与图：最近公共祖先、并查集
- 字符串：前缀树（字典树） ／ 后缀树

注意的点
---

对于看上去简单的题目, 很多时候就是事出反常必有妖, 例如

![](https://raw.githubusercontent.com/sansenlian/PicPlace/master/img/20190810204736.png)

以为num结果是6, 其实不是的, 没有break的话还会继续执行, 直到遇到break

---



## 利用函数特性

```JavaScript
// 使用箭头函数缩减代码
// 处理输入，可以用.map，需要注意其所有参数
// 此外其他迭代方法也需要掌握。
let line = readline().split(' ');
line = line.map((e) => parseInt(e));

// 去重
arr = [...new Set(arr)];
// 升序,排序可以用sort，默认是字典序,并且可以根据需要定制，需要深入掌握
arr.sort((a, b) => a - b);
// 迭代输出
arr.forEach((i) => console.log(i));
// 求最大值，使用扩展运算符...
max = Math.max.call(...arr);
max = Math.max.apply(...arr);
// 复制数组
arr2 = [...arr1];
arr2 = arr.concat();
arr2 = arr.slice();

// 善用解构
// 变量赋值
let [a, b, c, d, e] = [1, 2, 3, 4, 5]; // a=1,b=2,c=3,d=4,e=5
// 交换变量值
[a, b] = [b, a];

// 题外话：字符串中的字符是无法交换的
let str = 'ab';
[str[0], str[1]] = [str[1], str[0]]; // 无效，"ab"
// 不过可以将字符串拆成字符数组后就可以交换了
str = str.split(''); // ["a","b"]
[str[0], str[1]] = [str[1], str[0]]; // ["b","a"]
```
## 利用位运算
```JavaScript
// 求数组一半长度
halfLen = a.length >> 1;

// 不过需要注意右移运算符>>优先级别加号+还低，例如
console.log(3 + (5 - 3 >> 1)); // 2
console.log(3 + ~~((5 - 3) / 2)); // 4

// 因此在于其他操作符号想结合时候可以适当增加括 号,例如求中位
mid = left + (right - left >> 1);
mid = left + ~~((right - left) / 2);
// 不建议使用mid = (left + right)>>1;，因为加号操作可能造成溢出

// ~~等价于Math.floor(),|0也等价于Math.floor()
halfLen = ~~(a.length / 2);
halfLen = a.length / 2 | 0;

// 判断奇偶
evenNum & 1 === 0; // 偶数
oddNum & 1 === 1; // 奇数
// 判断数是否是2的幂次方, 如果是10000,num-1==01111,两个相与就是0
num & num - 1 === 0;

// 善用异或 可以用来去重
^ 5; // 0
^ 5 ^ 6 ^ 6 ^ 7; // 7



// 翻转数的第K位
num ^= 1 << k;

// 将第K位设为0, 与上自己相反的
num &= ~(1 << k);

// 将第K位设为1, 因为|第K位置只要有1就肯定是1
num |= 1 << K;

// 判断第K位是否为0, 因为1与1相与为1, 与0相与为
num & 1 << k === 0;
```
## 善用正则
（只要关于字符串的题目都应该联想到用正则表达式）

要会写正则，可以用正则表达式的几个函数也要掌握

正则中：exec，test

字符串中：search，match，replace，split
## 少写函数
刷题不是写业务代码，没有说要封装重用，AC才是王道。

并且写函数还要思考需要哪些参数，参数如何传递，会影响思考速度。

我们尽量做到的是，思考清楚后直接敲，越快越好，而不是一遍敲一边思考。
## 递归函数
前面情况有例外，比如要写递归，就要写函数。递归函数可以减少代码。

不过还是建议用递归思想去想，用循环搭配数据结构（栈/队列）去解答
## 刷题方法
1.审题先判断陷阱。

看到题目第一先看是否有时间复杂度、空间复杂度的要求。（比如大数问题、递归多了栈溢出等问题）

根据自己猜测判断使用简单方法，还是复杂方法来做，毕竟我们没有时间去做两遍题目。

然后再顺便看下是否需要判断边界条件（一般都需要出错判断）

有时间复杂度要求的，可以优化排序、动态规划、以空间换时间等

有空间复杂度要求的，可以用循环代替递归、动态规划代替递归等

这里讲下为什么不说贪心，第一理论上所有贪心可以解决的问题都可以用动态规划来做，第二正因如此，许多公司难题也就只考到了动态规划。

所以请一定一定要掌握动态规划。



2.联想。

我们遇到题目时要把题目和以前做过的题联想下，通过类似点，找出突破点。

字符串问题 ------》正则
链表、数组问题------》双指针
数组问题------》利用数组下标来做------》有时需要额外数组==》此外大部分要考虑二分法优化时间复杂度
多维数组问题------》降维来做。
复杂问题、优化问题------》动态规划
排列问题------》递归、回溯
数论问题------》找规律、动态规划
树的问题------》递归、深度遍历、广度遍历------》栈、队列
次数问题------》哈希表存储（js中建议使用{}，而不要使用ES6中的Map）
大小值问题------》栈、队列、哈希表做存储
从前往后、从大到小比较复杂------》从后往前、从小到大思考。
动态规划重点了解
位运算也了解一下


3.必须掌握算法

快排和归并排序、深度和广度遍历、二分查找（能手撕）

动态规划、回溯法。

要专门根据题目分类去刷这些算法。



4.多画图。

对于涉及数据结构的题目，如链表、二叉树等一定要画图。

对于涉及概率的问题，可以画圈圈来交、并、补。

对于点线的问题，可以画坐标系。



5.多举例

对于复杂问题可以举不复杂的小例子来分析步骤。

对于数论问题可以举例子来找规律。

退一万步来说，假设你实在不会做，你也可以通过举例，自己if-else生产很多测试用例去满足题意。

这也是为什么我们刷题时，题目不会像剑指offer题目一样，告诉你的答案和题目的测试用例有哪些不同的原因。



6.剩下的能淘汰你的只有智力题了。